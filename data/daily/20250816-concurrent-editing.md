---
title: 2025-08-16 Open Up Yorkie 동시 편집 세미나
description: OSSCA에서 진행된 Yorkie 동시 편집 세미나를 들으며 메모d
---

노션, 피그마는 어떻게 동시 편집이 가능할까? 슬랙, excalidraw, 구글독스 등 동시 편집을 지원하는 다양한 툴들이 있다. 어떻게 동작할까? 실시간 동시 편집의 구현은 어떻게 개선되어 왔을까?

## 협업의 역사

처음에는 파일로 주고받았다. 진짜최종, 진짜진짜최종 같은 한글, 엑셀 파일 등을 주고받음

이후에는 git으로 충돌 감지를 할 수 있게 됐다.

결국 등장한 "실시간 동시 편집 툴" figma, notion등. 실시간으로 다른 사람의 작업을 보고 코멘트를 남길 수도 있다.

## 구현에서 나오는 문제

어떻게 구현할까? 일단 상황을 생각해 보면

- 모두가 보고 있는, 공유되고 있는 원본 데이터가 있다
- 여러 사람이 수정가능
- 인터넷, 네트워크 등을 통해 주고 받는다

동시성, 시간 문제, 부분 단절 문제 등등이 발생...

## 변경 가능한 상태의 공유 문제

사실 변경되지 않는 상태의 공유는 별 문제가 없다. 책을 생각해 보면 된다.

하지만 변경될 수 있는 상태는? 예를 들어 티켓을 사는 걸 생각해본다.

1. 티켓이 몇장 남았는지 확인
2. 감산 가능하면 티켓을 감산
3. 티켓을 1장 줄인 값으로 저장

근데 티켓이 2장 남은 상태인데 이걸 10명이 동시에 하면 문제가 발생할 것!

문서 편집에도 이런 기능이 발생하는가? 발생한다. 이를 해결하는 방법은 기본적인 건 값 확인, 변경, 저장을 한번에 하도록 하는 것

- 데이터 조작 주체 제한. 락을 걸어서 한번에 1명만 편집 가능하게 한다.
- 최신값이 아닌 경우 재시도. 각 값의 버전을 관리하여 값의 버전을 보고 최신값이 아닌 경우 재시도를 하도록 한다

이런 방법들이 있지만 문제는 느리다는 거. 락도 느리고 인터넷 환경도 느리며 가변적이다.

그럼 어떻게 지연을 줄일까?

## 개선 방식들

### Local first remote later

로컬에서 문서 복제본 갖고 있고 이를 편집. 주기적으로 원격에 보내서 원격에 있는 문서 업데이트. 이렇게 하면 로컬에서 고치는 것처럼 사용자는 빠르게 변경을 할 수 있고 원본문서에는 적당한 간격으로 반영된다.

좋기는 한데 여전히 동시성 문제 발생. 내가 고친 곳이 원격에 반영되기 전에 다른 사람이 또 고쳤다면? 여러 곳에서 데이터를 관리하면서 더 동시성 문제가 심각해졌다.

### Operational transformation

중앙 서버에서 중재를 해주자. 한녀석이 다 정리하게 하는 것!

근데 이렇게 하면 문서 동시 편집의 경우 의도가 유지되지 않는 문제가 있다. 가령 두 명이 한곳에 바보/천재를 함께 넣었으면 insert index가 뒤섞여서 "바천보재"같은 이상한 내용이 될 수 있다.

즉 인덱스가 밀려나거나 변경된 만큼 조정을 해줘야 하는 문제 발생 -> 버퍼 안 operation들의 인덱스를 순서에 맞게 변환(transformation)해야 한다. 그래서 이름이 operational transformation이다.

근데 문제가 있음.

- 중앙 서버에 부하가 너무 큼. 변경 연산들을 정렬하는 건 복잡도가 크다.
- 발생 가능한 경우의 수가 너무 많아서 알고리즘이 너무 어렵다.

### CRDT

Conflict-free Replicated Data Type

강한 최종적 일관성.

- 모든 읽기작업은 항상 가장 최근에 완료된 데이터를 반환한다
- 모든 복제본은 결국 마지막 쓰기 값으로 수렴한다

업데이트 요청 순서랑은 상관 없이 연산들의 세트가 동일하면 결국 동일한 결과로 수렴한다는 것. 이 수렴은 로컬에서 처리

이를 위해서는 변경 연산들이 교환법칙, 결합법칙, 멱등성을 만족하도록 구현하면 된다! 어떻게? 논리 시계라는 걸 활용한다.

왜 진짜 시간을 쓸 수 없을까? 분산 시스템에서 시간을 따지는 건 사실 굉장히 힘들다...컴퓨터는 크리스탈 진동을 통해 시간을 판단하고 NTP(Network Time Protocol)를 이용해서 주기적으로 시간 정확도를 보완한다. 근데 우리는 인터넷을 통해서 하고 있기 때문에 시간을 통해 선후를 따지기가 어렵다.

결국 중요한 건 정렬 규칙을 정해서 받는 시간에 상관없이 "최종적으로 같은 결과로 수렴하도록"하는 것
멱등성 덕분에 2번 적용되지 않게도 가능

장점

- OT보다 시간 복잡도 낮고 중앙서버 부하 X(정렬이 로컬에서 규칙대로 일어나므로)
- 분산 네트워크, 장애에 강함. 어차피 정렬 규칙에 따라 정렬 결과는 똑같이 수렴하기 때문에 특정인의 변경사항이 어떤 네트워크 문제 등으로 인해서 나중에 전파되더라도 결국 똑같은 결과를 낼 수 있음
- 이론상 P2P 가능. 정렬 규칙만 서로 정해져 있으면 편집 결과물의 수렴은 똑같이 하기 때문에 중앙 서버도 없어도 된다.

또한 인덱스를 소수점으로 정의하는 등(figma에서 사용하는 알고리즘) 여러 베리에이션도 가능

한계

- 물론 의도를 반영해서 동시 편집을 하는 건 여전히 좀 힘듬(interleaving)
  - CRDT는 일종의 인터페이스로서 정말 단순하게는 Last Write Wins로 할 수 있다
  - 이런 건 구현체에서 해결할 문제

TreeDoc, WOOT 등은 이런 문제를 겪지 않지만 매우 느리다. 따라서 이런 인터리빙을 좀 해결하면서도 상대적으로 빠른 RGA를 Yorkie에서 채택

RGA의 아이디어: 어떤 글자는 다른 글자의 뒤에 있다는 당연한 사실에서 출발. "자기 앞의 글자" 그러니까 자기가 누구의 뒤에 있어야 하는지를 각 글자가 가지고 있다.
이때 경합은 글자끼리 일어나는 게 아니라, "같은 글자 뒤에 붙으려고 하는 글자 무리들"간에만 일어난다. 예를 들어 '안녕'뒤에 '하세요' 와 '반가워'가 붙으려고 한다. 다른 CRDT 인터페이스라면 '하세요'랑 '반가워' 각 글자 사이에 경합이 일어나서 '안녕하반가워세요' 같은 게 생길 수 있다. 그런데 RGA같은 경우 '반가워' 와 '하세요'간에만 경합이 생긴다. 따라서 '안녕 반가워 하세요' 정도로 의도가 어느 정도 유지된다.

Yorkie를 비롯하여 이런 동시편집을 구현하는 다른 툴들도 있다.

CRDT는 이론상 분산 시스템에서 다 처리할 수 있지만 중앙 서버가 있으면 기술적 난이도가 훨씬 낮아지고 엣지 케이스도 많이 줄어든다.
